name: Changelog Update

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]

permissions:
  contents: write

jobs:
  update-changelog:
    name: Update CHANGELOG.md
    if: github.event.pull_request.head.repo.full_name == github.repository
    runs-on: ubuntu-latest

    steps:
      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.ref }}
          fetch-depth: 0

      - name: Get PR diff
        run: |
          BASE_SHA=$(jq -r .pull_request.base.sha "$GITHUB_EVENT_PATH")
          HEAD_SHA=$(jq -r .pull_request.head.sha "$GITHUB_EVENT_PATH")

          git diff --unified=3 "$BASE_SHA" "$HEAD_SHA" > pr.diff

          MAX_BYTES=45000
          ACTUAL_BYTES=$(wc -c < pr.diff || echo 0)
          if [ "$ACTUAL_BYTES" -gt "$MAX_BYTES" ]; then
            head -c "$MAX_BYTES" pr.diff > pr_truncated.diff
            echo "::warning::Diff was too large ($ACTUAL_BYTES bytes). Truncated to $MAX_BYTES bytes."
            mv pr_truncated.diff pr.diff
          fi

      - name: Call OpenAI
        id: openai
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          OPENAI_PROJECT_ID: ${{ secrets.OPENAI_PROJECT_ID }}
        run: |
          if [ -z "$OPENAI_API_KEY" ]; then
            echo "changelog=Missing OPENAI_API_KEY secret." >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [ -z "$OPENAI_PROJECT_ID" ]; then
            echo "changelog=Missing OPENAI_PROJECT_ID secret." >> "$GITHUB_OUTPUT"
            exit 0
          fi

          CHANGELOG_CONTEXT=$(head -n 120 CHANGELOG.md)

          DIFF_CONTENT=$(cat pr.diff)

          PROMPT="You are updating a changelog. Use the existing CHANGELOG format for Notoli. Given the changelog context and a git diff, produce concise changelog items grouped by section. Output JSON ONLY with keys: added, changed, fixed, removed. Each value is an array of strings (bullet texts without leading '-'). Use sentence case, keep it short, and do not include dates or section headers. If a section has no items, use an empty array.\n\nCHANGELOG CONTEXT:\n${CHANGELOG_CONTEXT}\n\nDIFF:\n${DIFF_CONTENT}\n"

          jq -n \
            --arg prompt "$PROMPT" \
            '
            {
              model: "gpt-5.1",
              temperature: 0.2,
              messages: [
                { "role": "system", "content": "You write changelog entries matching the existing format." },
                { "role": "user", "content": $prompt }
              ]
            }
            ' > body.json

          RESPONSE=$(curl -s -X POST "https://api.openai.com/v1/chat/completions" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -H "OpenAI-Project: $OPENAI_PROJECT_ID" \
            --data @body.json)

          CHANGELOG_JSON=$(echo "$RESPONSE" | jq -r '
            if .choices and .choices[0].message and .choices[0].message.content then
              .choices[0].message.content
            elif .error and .error.message then
              "{\"added\":[],\"changed\":[],\"fixed\":[],\"removed\":[],\"error\":\"" + .error.message + "\"}"
            else
              "{\"added\":[],\"changed\":[],\"fixed\":[],\"removed\":[]}"
            end
          ')

          {
            echo 'changelog<<EOF'
            printf '%s\n' "$CHANGELOG_JSON"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

      - name: Update CHANGELOG.md
        env:
          CHANGELOG_JSON: ${{ steps.openai.outputs.changelog }}
        run: |
          DATE=$(date -u +%Y-%m-%d)
          export DATE
          ADDED_FILE=$(mktemp)
          CHANGED_FILE=$(mktemp)
          FIXED_FILE=$(mktemp)
          REMOVED_FILE=$(mktemp)

          echo "$CHANGELOG_JSON" | jq -r '.added[]' | sed 's/^/- /' > "$ADDED_FILE" || true
          echo "$CHANGELOG_JSON" | jq -r '.changed[]' | sed 's/^/- /' > "$CHANGED_FILE" || true
          echo "$CHANGELOG_JSON" | jq -r '.fixed[]' | sed 's/^/- /' > "$FIXED_FILE" || true
          echo "$CHANGELOG_JSON" | jq -r '.removed[]' | sed 's/^/- /' > "$REMOVED_FILE" || true

          filter_existing() {
            local file="$1"
            if [ ! -s "$file" ]; then
              return 0
            fi
            grep -Fvx -f CHANGELOG.md "$file" > "${file}.tmp" || true
            mv "${file}.tmp" "$file"
          }

          filter_existing "$ADDED_FILE"
          filter_existing "$CHANGED_FILE"
          filter_existing "$FIXED_FILE"
          filter_existing "$REMOVED_FILE"

          if [ ! -s "$ADDED_FILE" ] && [ ! -s "$CHANGED_FILE" ] && [ ! -s "$FIXED_FILE" ] && [ ! -s "$REMOVED_FILE" ]; then
            echo "No changelog entries to add."
            exit 0
          fi

          if ! grep -q "^## ${DATE}$" CHANGELOG.md; then
            BLOCK_FILE=$(mktemp)
            {
              echo "## ${DATE}"
              if [ -s "$ADDED_FILE" ]; then
                echo "### Added"
                cat "$ADDED_FILE"
              fi
              if [ -s "$CHANGED_FILE" ]; then
                echo "### Changed"
                cat "$CHANGED_FILE"
              fi
              if [ -s "$FIXED_FILE" ]; then
                echo "### Fixed"
                cat "$FIXED_FILE"
              fi
              if [ -s "$REMOVED_FILE" ]; then
                echo "### Removed"
                cat "$REMOVED_FILE"
              fi
              echo ""
            } > "$BLOCK_FILE"

            awk -v blockfile="$BLOCK_FILE" '
              BEGIN { inserted = 0; while ((getline line < blockfile) > 0) { block = block line "\n" } }
              /^## / && !inserted { printf "%s", block; inserted = 1 }
              { print }
              END { if (!inserted) printf "%s", block }
            ' CHANGELOG.md > CHANGELOG.md.tmp
            mv CHANGELOG.md.tmp CHANGELOG.md
            exit 0
          fi

          export DATE
          export ADDED_FILE
          export CHANGED_FILE
          export FIXED_FILE
          export REMOVED_FILE

          awk '
            BEGIN {
              date = ENVIRON["DATE"]
              added_file = ENVIRON["ADDED_FILE"]
              changed_file = ENVIRON["CHANGED_FILE"]
              fixed_file = ENVIRON["FIXED_FILE"]
              removed_file = ENVIRON["REMOVED_FILE"]
              added_n = load_lines(added_file, added)
              changed_n = load_lines(changed_file, changed)
              fixed_n = load_lines(fixed_file, fixed)
              removed_n = load_lines(removed_file, removed)
            }

            function load_lines(path, arr,   i, line) {
              i = 0
              while ((getline line < path) > 0) {
                i++
                arr[i] = line
              }
              close(path)
              return i
            }

            function emit_section(name, arr, n,   i) {
              if (n == 0) return
              print "### " name
              for (i = 1; i <= n; i++) {
                print arr[i]
              }
              print ""
            }

            function emit_missing_sections(   i) {
              if (!seen_added) emit_section("Added", added, added_n)
              if (!seen_changed) emit_section("Changed", changed, changed_n)
              if (!seen_fixed) emit_section("Fixed", fixed, fixed_n)
              if (!seen_removed) emit_section("Removed", removed, removed_n)
            }

            /^## / {
              if (in_date) {
                emit_missing_sections()
              }
              in_date = ($0 == "## " date)
            }

            in_date && $0 == "### Added" {
              seen_added = 1
              print $0
              for (i = 1; i <= added_n; i++) print added[i]
              added_n = 0
              next
            }
            in_date && $0 == "### Changed" {
              seen_changed = 1
              print $0
              for (i = 1; i <= changed_n; i++) print changed[i]
              changed_n = 0
              next
            }
            in_date && $0 == "### Fixed" {
              seen_fixed = 1
              print $0
              for (i = 1; i <= fixed_n; i++) print fixed[i]
              fixed_n = 0
              next
            }
            in_date && $0 == "### Removed" {
              seen_removed = 1
              print $0
              for (i = 1; i <= removed_n; i++) print removed[i]
              removed_n = 0
              next
            }

            { print }

            END {
              if (in_date) {
                emit_missing_sections()
              }
            }
          ' CHANGELOG.md > CHANGELOG.md.tmp
          mv CHANGELOG.md.tmp CHANGELOG.md

      - name: Commit changelog
        run: |
          if git diff --quiet; then
            echo "No changelog changes to commit."
            exit 0
          fi

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add CHANGELOG.md
          git commit -m "Update changelog"
          git push
