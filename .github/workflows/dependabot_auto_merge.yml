name: Dependabot Auto Merge

on:
  workflow_call:
    inputs:
      tests_result:
        required: true
        type: string
      lints_result:
        required: true
        type: string
      pr_number:
        required: true
        type: number
      pr_author:
        required: true
        type: string

permissions:
  contents: write
  pull-requests: write

jobs:
  dependabot-auto-merge:
    name: Dependabot Auto Merge
    if: inputs.pr_author == 'dependabot[bot]' && inputs.lints_result == 'success' && inputs.tests_result == 'success'
    runs-on: ubuntu-latest
    env:
      PR_NUMBER: ${{ inputs.pr_number }}
    steps:
      - name: Fetch Dependabot metadata
        id: metadata
        uses: dependabot/fetch-metadata@v2
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Enable auto-merge
        if: steps.metadata.outputs.update-type == 'version-update:semver-patch' || steps.metadata.outputs.update-type == 'version-update:semver-minor'
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const pull_number = Number(process.env.PR_NUMBER);

            if (!pull_number) {
              core.warning('PR number is not available; skipping.');
              return;
            }

            let pr;
            const { data } = await github.rest.pulls.get({ owner, repo, pull_number });
            pr = data;

            if (!pr) {
              core.warning('PR data not available; skipping auto-merge handling.');
              return;
            }

            if (pr.merged || pr.draft) {
              core.info('PR is already merged or a draft; skipping auto-merge.');
              return;
            }

            if (pr.mergeable === false || pr.mergeable_state === 'dirty') {
              core.warning('PR has merge conflicts; skipping.');
              return;
            }

            if (pr.auto_merge) {
              core.info('Auto-merge is already enabled; skipping.');
              return;
            }

            if (pr.mergeable === true && pr.mergeable_state === 'unstable') {
              core.warning('PR is unstable; attempting immediate merge anyway.');
              try {
                await github.rest.pulls.merge({
                  owner,
                  repo,
                  pull_number,
                  merge_method: 'merge',
                });
                core.info('PR merged directly while unstable.');
              } catch (error) {
                const message = error?.message || 'Unknown error';
                core.warning(`Immediate merge failed: ${message}`);
              }
              return;
            }

            if (pr.mergeable == null || pr.mergeable_state === 'unknown' || pr.mergeable_state === 'unstable') {
              core.warning('PR is not yet in a stable mergeable state; skipping for now.');
              return;
            }

            const mutation = 'mutation($pullRequestId: ID!, $mergeMethod: PullRequestMergeMethod!) { enablePullRequestAutoMerge(input: { pullRequestId: $pullRequestId, mergeMethod: $mergeMethod }) { pullRequest { number } } }';
            try {
              await github.graphql(mutation, {
                pullRequestId: pr.node_id,
                mergeMethod: "MERGE",
              });
              core.info('Auto-merge enabled.');
            } catch (error) {
              const message = error?.message || 'Unknown error';
              core.warning(`Auto-merge not enabled: ${message}`);
            }
        env:
          PR_NUMBER: ${{ inputs.pr_number }}
