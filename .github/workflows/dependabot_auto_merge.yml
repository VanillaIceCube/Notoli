name: Dependabot Auto Merge

on:
  workflow_call:
    secrets:
      OPENAI_API_KEY:
        required: false
      OPENAI_PROJECT_ID:
        required: false

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  dependabot-auto-merge:
    name: Dependabot Auto Merge
    if: github.event.pull_request.user.login == 'dependabot[bot]'
    runs-on: ubuntu-latest
    env:
      PR_NUMBER: ${{ github.event.pull_request.number }}
    steps:
      - name: Fetch Dependabot metadata
        id: metadata
        uses: dependabot/fetch-metadata@v2
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Summarize major update with ChatGPT
        if: steps.metadata.outputs.update-type == 'version-update:semver-major'
        uses: actions/github-script@v8
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          OPENAI_PROJECT_ID: ${{ secrets.OPENAI_PROJECT_ID }}
          PACKAGE_NAME: ${{ steps.metadata.outputs.dependency-names }}
          OLD_VERSION: ${{ steps.metadata.outputs.previous-version }}
          NEW_VERSION: ${{ steps.metadata.outputs.new-version }}
          ECOSYSTEM: ${{ steps.metadata.outputs.package-ecosystem }}
          SCOPE: ${{ steps.metadata.outputs.dependency-type }}
        with:
          script: |
            const { owner, repo } = context.repo;
            const pull_number = Number(process.env.PR_NUMBER);
            const {
              OPENAI_API_KEY,
              OPENAI_PROJECT_ID,
              PACKAGE_NAME,
              OLD_VERSION,
              NEW_VERSION,
              ECOSYSTEM,
              SCOPE,
            } = process.env;

            if (!pull_number) {
              core.warning('PR number is not available; skipping summary comment.');
              return;
            }

            let summary = 'Missing OpenAI secrets; skipping summary.';
            if (OPENAI_API_KEY && OPENAI_PROJECT_ID) {
              const prompt = `Dependency Update Summary (Major)\n\nPackage: ${PACKAGE_NAME}\nFrom: ${OLD_VERSION}\nTo: ${NEW_VERSION}\nEcosystem: ${ECOSYSTEM}\nScope: ${SCOPE}\n\nProvide:\n- High-level changes (focus on breaking changes)\n- Required code/config changes (Yes/No + details)\n- Risk level (Low/Medium/High) with rationale\n- Test coverage confidence\n- Migration guide availability\n- Recommendation (merge later / do not merge / needs investigation)\n- TL;DR`;

              try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    Authorization: `Bearer ${OPENAI_API_KEY}`,
                    'OpenAI-Project': OPENAI_PROJECT_ID,
                  },
                  body: JSON.stringify({
                    model: 'gpt-5.1',
                    temperature: 0.2,
                    messages: [
                      { role: 'system', content: 'You summarize dependency major updates for maintainers.' },
                      { role: 'user', content: prompt },
                    ],
                  }),
                });
                const data = await response.json();
                summary = data?.choices?.[0]?.message?.content;
                if (!summary) {
                  summary = data?.error?.message
                    ? `OpenAI API error: ${data.error.message}`
                    : 'OpenAI did not return a summary.';
                }
              } catch (error) {
                summary = `OpenAI API error: ${error?.message || 'Unknown error'}`;
              }
            }

            const marker = '<!-- dependabot-major-summary -->';
            const summaryText = summary.trim();
            const body = `${summaryText}\n\n${marker}`;

            const comments = await github.paginate(github.rest.issues.listComments, {
              owner,
              repo,
              issue_number: pull_number,
              per_page: 100,
            });

            const existing = comments.find(
              (comment) =>
                comment.user &&
                comment.user.login === 'github-actions[bot]' &&
                typeof comment.body === 'string' &&
                comment.body.includes(marker)
            );

            if (existing) {
              const cleanedExisting = existing.body.replace(marker, '').trim();
              if (cleanedExisting === summaryText) {
                core.info('Summary comment already up to date; skipping.');
                return;
              }

              await github.rest.issues.updateComment({
                owner,
                repo,
                comment_id: existing.id,
                body,
              });
              core.info('Summary comment updated.');
              return;
            }

            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: pull_number,
              body,
            });
            core.info('Summary comment posted.');

      - name: Enable auto-merge
        if: steps.metadata.outputs.update-type == 'version-update:semver-patch' || steps.metadata.outputs.update-type == 'version-update:semver-minor'
        uses: actions/github-script@v8
        with:
          script: |
            const { owner, repo } = context.repo;
            const pull_number = Number(process.env.PR_NUMBER);
            const wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

            if (!pull_number) {
              core.warning('PR number is not available; skipping.');
              return;
            }

            let pr;
            const maxAttempts = 36;
            for (let attempt = 1; attempt <= maxAttempts; attempt += 1) {
              if (attempt > 1) {
                await wait(5000);
              }
              const { data } = await github.rest.pulls.get({ owner, repo, pull_number });
              pr = data;
              if (
                pr.mergeable !== null &&
                pr.mergeable_state &&
                pr.mergeable_state !== 'unknown' &&
                pr.mergeable_state !== 'unstable'
              ) {
                break;
              }
            }

            if (!pr) {
              core.warning('PR data not available; skipping auto-merge handling.');
              return;
            }

            if (pr.merged || pr.draft) {
              core.info('PR is already merged or a draft; skipping auto-merge.');
              return;
            }

            if (pr.mergeable === false || pr.mergeable_state === 'dirty') {
              core.warning('PR has merge conflicts; skipping.');
              return;
            }

            if (pr.auto_merge) {
              core.info('Auto-merge is already enabled; skipping.');
              return;
            }

            if (pr.mergeable == null || pr.mergeable_state === 'unknown' || pr.mergeable_state === 'unstable') {
              core.warning('PR is not yet in a stable mergeable state; skipping for now.');
              return;
            }

            const mutation = 'mutation($pullRequestId: ID!, $mergeMethod: PullRequestMergeMethod!) { enablePullRequestAutoMerge(input: { pullRequestId: $pullRequestId, mergeMethod: $mergeMethod }) { pullRequest { number } } }';
            try {
              await github.graphql(mutation, {
                pullRequestId: pr.node_id,
                mergeMethod: "MERGE",
              });
              core.info('Auto-merge enabled.');
            } catch (error) {
              const message = error?.message || 'Unknown error';
              core.warning(`Auto-merge not enabled: ${message}`);
            }
