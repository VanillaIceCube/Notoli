name: Commentary

on:
  workflow_call:
    inputs:
      lint_frontend_status:
        description: Frontend lint status (success/failure/none).
        required: false
        type: string
      lint_frontend_log:
        description: Frontend lint log tail.
        required: false
        type: string
      lint_backend_status:
        description: Backend lint status (success/failure/none).
        required: false
        type: string
      lint_backend_log:
        description: Backend lint log tail.
        required: false
        type: string
      test_frontend_status:
        description: Frontend test status (success/failure/none).
        required: false
        type: string
      test_frontend_log:
        description: Frontend test log tail.
        required: false
        type: string
      test_backend_status:
        description: Backend test status (success/failure/none).
        required: false
        type: string
      test_backend_log:
        description: Backend test log tail.
        required: false
        type: string
    secrets:
      OPENAI_API_KEY:
        required: false

concurrency:
  group: commentary-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  ai-summary:
    name: ai-summary
    if: github.actor != 'dependabot[bot]'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout PR
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Get PR diff
        id: pr_diff
        uses: ./.github/actions/get-pr-diff
        with:
          base_sha: ${{ github.event.pull_request.base.sha }}
          head_sha: ${{ github.event.pull_request.head.sha }}
          max_bytes: "45000"

      - name: Call OpenAI (Summary)
        id: openai
        uses: ./.github/actions/openai-chat
        with:
          api_key: ${{ secrets.OPENAI_API_KEY }}
          project_id: ${{ vars.OPENAI_PROJECT_ID }}
          diff_path: ${{ steps.pr_diff.outputs.diff_path }}
          model: "gpt-5.1"
          temperature: "0.3"
          system_prompt: "You are an experienced PR summarizer helping on GitHub pull requests."
          prompt_prefix: |
            You are a PR summarizer for the Notoli project (Backend: Django; Frontend: React + MUI; Docker; GitHub Actions). Produce a high-level, human-readable digest of what changed and why it matters. Focus on intent, scope, behavior changes, and impact. Do NOT do a code review. Do NOT list line-by-line or file-by-file changes. Do NOT restate the diff. Be concise. If the diff is truncated, explicitly note that the summary may be incomplete. Your response MUST use the following exact sections, in order, each containing bullet points (or '(none)' if empty): ## ðŸ“Œ Summary (what & why): ## ðŸ“‚ Scope (what areas are affected): ## ðŸ”„ Behavior Changes (user-visible or API-visible): Here is the diff:

      - name: Update PR Description
        uses: actions/github-script@v8
        env:
          SUMMARY_BODY: ${{ steps.openai.outputs.content }}
        with:
          script: |
            const body = process.env.SUMMARY_BODY;
            if (!body) {
              core.warning('Summary body is empty; skipping PR update.');
              return;
            }

            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number,
            });

            const existingBody = (pr.body || '').trim();
            if (!existingBody || existingBody.startsWith('...')) {
              await github.rest.pulls.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.payload.pull_request.number,
                body,
              });
              return;
            }

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body,
            });

  ai-review:
    name: ai-review
    if: github.actor != 'dependabot[bot]'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout PR
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Get PR diff
        id: pr_diff
        uses: ./.github/actions/get-pr-diff
        with:
          base_sha: ${{ github.event.pull_request.base.sha }}
          head_sha: ${{ github.event.pull_request.head.sha }}
          max_bytes: "45000"

      - name: Call OpenAI (Review)
        id: openai_review
        uses: ./.github/actions/openai-chat
        with:
          api_key: ${{ secrets.OPENAI_API_KEY }}
          project_id: ${{ vars.OPENAI_PROJECT_ID }}
          diff_path: ${{ steps.pr_diff.outputs.linediff_path }}
          model: "gpt-5.1"
          temperature: "0.2"
          system_prompt: "You are an experienced, pragmatic PR reviewer."
          prompt_prefix: |
            You are a PR reviewer for the Notoli project (Backend: Django; Frontend: React + MUI; Docker; GitHub Actions). Provide a concise, high-signal code review focused on correctness, security, and maintainability risks. Flag potential bugs, edge cases, missing tests, or backwards-incompatible changes. Avoid style nitpicks. If you are unsure, say so. Use the line-numbered diff to anchor inline comments.

            Return ONLY strict JSON (no markdown, no code fences) with this shape:
            {
              "event": "APPROVE" | "REQUEST_CHANGES" | "COMMENT",
              "body": "overall review summary",
              "comments": [
                { "path": "relative/file/path", "line": 123, "body": "inline comment" }
              ]
            }

            Rules:
            - Use only line numbers shown as "A<line>:" in the diff (RIGHT side, added lines only).
            - Use file paths exactly as shown in the diff headers (e.g., "b/path" => "path").
            - Max 6 inline comments. If none, return an empty comments array.
            - If issues are critical, use REQUEST_CHANGES; if no issues, APPROVE; otherwise COMMENT.
            - If the diff is truncated, mention it in the body.

            CI context (lint/test results):
            - lint_frontend_status: ${{ inputs.lint_frontend_status || 'none' }}
            - lint_backend_status: ${{ inputs.lint_backend_status || 'none' }}
            - test_frontend_status: ${{ inputs.test_frontend_status || 'none' }}
            - test_backend_status: ${{ inputs.test_backend_status || 'none' }}
            - lint_frontend_log (tail):
            ${{ inputs.lint_frontend_log }}
            - lint_backend_log (tail):
            ${{ inputs.lint_backend_log }}
            - test_frontend_log (tail):
            ${{ inputs.test_frontend_log }}
            - test_backend_log (tail):
            ${{ inputs.test_backend_log }}

            Here is the line-numbered diff:

      - name: Create PR Review
        id: review_result
        uses: actions/github-script@v8
        env:
          REVIEW_BODY: ${{ steps.openai_review.outputs.content }}
        with:
          script: |
            const setOutputs = (eventValue, submittedValue) => {
              core.setOutput('review_event', eventValue);
              core.setOutput('review_submitted', submittedValue ? 'true' : 'false');
            };

            const raw = (process.env.REVIEW_BODY || '').trim();
            if (!raw) {
              core.warning('Review body is empty; skipping review.');
              setOutputs('NONE', false);
              return;
            }

            const nonJsonPrefixes = [
              'Missing secret(s):',
              'OpenAI API error:',
              'OpenAI did not return a response.',
              'OpenAI did not return a review.',
            ];

            if (nonJsonPrefixes.some((prefix) => raw.startsWith(prefix))) {
              core.warning(raw);
              setOutputs('NONE', false);
              return;
            }

            const stripCodeFences = (text) => {
              const trimmed = text.trim();
              if (!trimmed.startsWith('```')) return trimmed;
              return trimmed.replace(/^```[a-zA-Z]*\n?/, '').replace(/```$/, '').trim();
            };

            let parsed;
            try {
              parsed = JSON.parse(stripCodeFences(raw));
            } catch (err) {
              core.warning(`Failed to parse JSON review payload: ${err.message}`);
              parsed = null;
            }

            const allowedEvents = new Set(['APPROVE', 'REQUEST_CHANGES', 'COMMENT']);
            let event = 'COMMENT';
            let body = '';
            let comments = [];

            if (parsed) {
              event = allowedEvents.has(parsed.event) ? parsed.event : 'COMMENT';
              body = typeof parsed.body === 'string' ? parsed.body.trim() : '';
              comments = Array.isArray(parsed.comments) ? parsed.comments : [];
            } else {
              body = raw;
            }

            if (!body) {
              body = 'Automated review generated.';
            }

            const validLines = new Map();
            const buildValidLinesFromPatch = (path, patch) => {
              if (!patch) return;
              const lines = patch.split(/\r?\n/);
              let newLine = null;
              for (const line of lines) {
                if (line.startsWith('@@')) {
                  const match = line.match(/\+(\d+)(?:,(\d+))?/);
                  if (match) {
                    newLine = Number(match[1]);
                  }
                  continue;
                }
                if (newLine === null) continue;
                if (line.startsWith('+') && !line.startsWith('+++')) {
                  if (!validLines.has(path)) validLines.set(path, new Set());
                  validLines.get(path).add(newLine);
                  newLine += 1;
                  continue;
                }
                if (line.startsWith(' ') || line.startsWith('-')) {
                  if (!line.startsWith('-')) {
                    newLine += 1;
                  }
                  continue;
                }
              }
            };

            const prNumber = context.payload.pull_request.number;
            const files = [];
            let page = 1;
            while (true) {
              const { data } = await github.rest.pulls.listFiles({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                per_page: 100,
                page,
              });
              if (!data || data.length === 0) break;
              files.push(...data);
              if (data.length < 100) break;
              page += 1;
            }

            for (const file of files) {
              if (!file?.filename) continue;
              buildValidLinesFromPatch(file.filename, file.patch);
            }

            const normalizePath = (path) =>
              typeof path === 'string' ? path.replace(/^b\//, '').trim() : '';

            const filteredComments = [];
            let dropped = 0;
            for (const comment of comments) {
              const path = normalizePath(comment?.path);
              const line = Number(comment?.line);
              const text = typeof comment?.body === 'string' ? comment.body.trim() : '';
              if (!path || !text || Number.isNaN(line)) {
                dropped += 1;
                continue;
              }
              const allowed = validLines.get(path);
              if (!allowed || !allowed.has(line)) {
                dropped += 1;
                continue;
              }
              filteredComments.push({ path, line, side: 'RIGHT', body: text });
              if (filteredComments.length >= 6) break;
            }

            if (dropped > 0) {
              body += `\n\nNote: ${dropped} inline comment(s) could not be placed on valid lines.`;
            }

            await github.rest.pulls.createReview({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number,
              event,
              body,
              comments: filteredComments.length > 0 ? filteredComments : undefined,
            });

            setOutputs(event, true);
