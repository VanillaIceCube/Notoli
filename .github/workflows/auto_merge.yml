name: Auto Merge

on:
  workflow_call:
    secrets:
      DEPENDABOT_PAT:
        required: false

permissions:
  contents: write
  pull-requests: write
  issues: write
  security-events: read

jobs:
  dependabot-auto-merge:
    name: Dependabot Auto Merge
    if: github.event.pull_request.user.login == 'dependabot[bot]'
    runs-on: ubuntu-latest
    env:
      PR_NUMBER: ${{ github.event.pull_request.number }}
    steps:
      - name: Fetch Dependabot metadata
        id: metadata
        uses: dependabot/fetch-metadata@v2
        with:
          github-token: ${{ secrets.DEPENDABOT_PAT || secrets.GITHUB_TOKEN }}
          alert-lookup: true

      - name: Enable auto-merge
        uses: actions/github-script@v8
        env:
          UPDATE_TYPE: ${{ steps.metadata.outputs.update-type }}
          ALERT_STATE: ${{ steps.metadata.outputs.alert-state }}
          CVSS: ${{ steps.metadata.outputs.cvss }}
          CVSS_AUTO_MERGE_MAX: 6.9
        with:
          script: |
            const { owner, repo } = context.repo;
            const pull_number = Number(process.env.PR_NUMBER);
            const updateType = process.env.UPDATE_TYPE;
            const alertState = process.env.ALERT_STATE;
            const cvssRaw = process.env.CVSS;
            const cvssLimit = Number(process.env.CVSS_AUTO_MERGE_MAX || '6.9');
            const cvssScore = Number.parseFloat(cvssRaw);

            const isPatchOrMinor =
              updateType === 'version-update:semver-patch' ||
              updateType === 'version-update:semver-minor';
            const isLowSeveritySecurity =
              alertState === 'OPEN' &&
              Number.isFinite(cvssScore) &&
              cvssScore <= cvssLimit;

            if (!isPatchOrMinor && !isLowSeveritySecurity) {
              core.info(
                `Auto-merge skipped: update-type=${updateType}, alert-state=${alertState}, cvss=${cvssRaw}`
              );
              return;
            }

            if (!pull_number) {
              core.warning('PR number is not available; skipping.');
              return;
            }

            const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

            let pr;
            for (let attempt = 0; attempt < 60; attempt += 1) {
              const { data } = await github.rest.pulls.get({ owner, repo, pull_number });
              pr = data;

              if (!pr) {
                core.warning('PR data not available; skipping auto-merge handling.');
                return;
              }

              if (pr.mergeable !== null && pr.mergeable_state !== 'unknown') {
                break;
              }

              if (attempt < 59) {
                core.info('Mergeability not ready yet; retrying in 5 seconds.');
                await sleep(5000);
              }
            }

            if (pr.merged || pr.draft) {
              core.info('PR is already merged or a draft; skipping auto-merge.');
              return;
            }

            if (pr.mergeable === false || pr.mergeable_state === 'dirty') {
              core.warning('PR has merge conflicts; skipping.');
              return;
            }

            if (pr.auto_merge) {
              core.info('Auto-merge is already enabled; skipping.');
              return;
            }

            if (pr.mergeable === true && pr.mergeable_state === 'unstable') {
              core.warning('PR is unstable; attempting immediate merge anyway.');
              try {
                await github.rest.pulls.merge({
                  owner,
                  repo,
                  pull_number,
                  merge_method: 'merge',
                });
                core.info('PR merged directly while unstable.');
              } catch (error) {
                const message = error?.message || 'Unknown error';
                core.warning(`Immediate merge failed: ${message}`);
              }
              return;
            }

            if (pr.mergeable == null || pr.mergeable_state === 'unknown' || pr.mergeable_state === 'unstable') {
              core.warning('PR is not yet in a stable mergeable state; skipping for now.');
              return;
            }

            const mutation = 'mutation($pullRequestId: ID!, $mergeMethod: PullRequestMergeMethod!) { enablePullRequestAutoMerge(input: { pullRequestId: $pullRequestId, mergeMethod: $mergeMethod }) { pullRequest { number } } }';
            try {
              await github.graphql(mutation, {
                pullRequestId: pr.node_id,
                mergeMethod: "MERGE",
              });
              core.info('Auto-merge enabled.');
            } catch (error) {
              const message = error?.message || 'Unknown error';
              core.warning(`Auto-merge not enabled: ${message}`);
            }
